1. Once I have the command stored, if the command is a GOTO, GOSUB or IF, my program has another if statement that checks if the line jump is valid by using map::count on my line map at a index of a vector. This first occurs on line 490-500 of my interpreter.cpp, in the GOTO part, and is the same for GOSUB and IF. Map::count on my line map takes Θ(logn), n being the size of the map, and vector operator[] is constant, so this operation simplifies to just Θ(logn). If the line is valid, then I get the int value of the Jline through a recursive call on a vector index (which, once again, is constant) that takes constant time, since it only gets called twice: once on the command, then once on that command's stored Jline. On line 492, I then use that value as an index to access that element of my line map with operator[], which takes Θ(logn) time, n being the size of this map. I then continue, which takes constant time. If the line is invalid, then I cout the error message, calling getLine and getJline, which takes linear time as explained above, on vector index i, using vector operator[], which also takes constant time. I then call break, terminating my program, meaning this part has constant runtime, Θ(1).
Figuring out and going to the jump line of GOTO, GOSUB, or IF, therefore takes my program either Θ(1) or Θ(logn+logn) time, which simplifies to Θ(log(n*n)), which equals Θ(log(n^2)), or Θ(2logn). However, since the 2 is a constant factor, it can be ignored, for a final Θ(logn) runtime if the jump line is valid or Θ(1) runtime otherwise.

2. For RETURN commands, on lines 546-557 of interpreter.cpp I have an if statement that checks if the stack I store my jump lines in is empty. The .empty() operation takes constant time. If it is empty, then I print an error message and break, which takes constant time, as previously explained. If the stack is not empty, then my program gets the line at the top of the stack with .top(), which takes constant time. I then .pop() said command, which also takes constant time. Finally, I use the value I got from .top() as a key to my line map via map operator[] to get the index I should use for my next iteration, which has Θ(logn) runtime, n being the size of the map.
Therefore, my RETURN process' runtime simplifies to Θ(logn).

3. On lines 481-483 of my interpreter.cpp I have an If statement that checks if the command in question is a LET command. If it is, then I immediately call getVal on it. This takes us to lines 62-83 of command.cpp, where I define getVal. On line 63, I get the int value of the Numeric Expression I'm setting the variable equal to. After that, I initialize a temporary map that I use to store the existing value of the variable. I do this through the use of map operator[] on the larger outside map, which takes log(n) time, n being the size of the map. I use a map because it was an easier way to implement storing variables and variable arrays in the same place. The "index" for simple variables is always the same large number, so I can alwasy access it just as easily. After updating the temp map, I add the value I just recursively calculated to the map through operator[] once again, which has log(m) time, m being the size of the inner map. After that, I set the outer map's inner map equal to the temp map, updating the outer map with the new value, which takes log(n+1) time, n being the size of the original map, which just got incremented by 1. I then return the value I calculated in the beginning.
In the end, getting the value of a variable takes log(m)+log(n)+log(n+1). This simplifies to log(m)+log(n)+log(n), which simplifies to log(n^2)+log(m), which simplifies to 2log(n)+log(m), which simplifies to log(n)+log(m), which finally simplifies to log(nm), resulting in a Θ(log(nm) runtime.

4. On lines 485-487 of my interpreter.cpp I have an If statement that checks if the command in question is a LETARR command. If it is, then I immediately call getVal on it. This takes us to lines 118-136 of command.cpp, where I define getVal. On lines 119-120, I get the int values of the Numeric Expressions for the index and for the value I'm setting the variable equal to. After that, I initialize a temporary map that I use to store the existing values of the array. I do this through the use of map operator[] on the larger outside map, which takes log(n) time, n being the size of the map. After updating the temp map, I add the value I just recursively calculated to the index I also calculated to the map through operator[] once again, which has log(m) time, m being the size of the inner map. After that, I set the outer map's inner map equal to the temp map, updating the outer map with the new value, which takes log(n+1) time, n being the size of the original map, which just got incremented by 1. I then return the value I calculated in the beginning.
In the end, getting the value of an array entry takes log(m)+log(n)+log(n+1). This simplifies to log(m)+log(n)+log(n), which simplifies to log(n^2)+log(m), which simplifies to 2log(n)+log(m), which simplifies to log(n)+log(m), which finally simplifies to log(nm), resulting in a Θ(log(nm) runtime.